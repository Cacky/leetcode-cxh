贪心+二分，时间复杂度为O(nlogn)
下面说说贪心+二分的解法，举例说明基本思路，假设数组arr为[2, 3, 1, 2, 3]，vec数组里面存放递增子序列，maxLen数组里存放以元素i结尾的最大递增子序列长度，那么遍历数组arr并执行如下更新规则:

初始情况下，vec为[2]，maxLen[1]
接下来遇到3，由于vec最后一个元素小于3，直接更新，vec为[2,3]，maxLen[1,2]
接下来遇到1，由于vec最后的元素大于1, 我们在vec中查找大于等于1的第一个元素的下标，并用1替换之，此时vec为[1,3], maxLen[1,2,1]
接下来遇到2，由于vec最后的元素大于2，我们在vec中查找大于等于2的第一个元素的下标，并用2替换之，此时vec为[1,2], maxLen[1,2,1,2]
接下来遇到3，由于vec最后一个元素小于3，直接更新，vec为[1,2,3]，maxLen为[1,2,1,2,3]
此时vec的大小就是整个序列中最长递增子序列的长度（但是vec不一定是本题的最终解）
----------------------------------------------------------------------------------------
补充下贪心 + 二分的题解，很抽象、很难用文字解释：
例如 ： [2,1,5,3,6,4,8,9,7]
1、 辅助数组的含义
end[i] 表示 “长度为 i 的子序列的最后一位的最小值！”
（将索引 0 设为冗余位）可能有很多长度为 i 的子序列，但 end[i] 存全部长度为i 子序列中的 末位最小值， 所以 end 不是解，只是长度关联。
在遍历到 arr[7] 时， end 数组： [0, 1, 3, 4, 8, 9]
在遍历到 arr[8] 时， end 数组： [0, 1, 3, 4, 7, 9]， 可以注意到最后一位 arr[8] 元素 7 替换了 end[4] 的元素 8 。
 表明： 长度为 4 的子序列中，最后一位的最小值变为7。（1348 -> 1347）
2、 不要尝试证明贪心算法！！！
3、 怎么找到字典序最小的解
需要 maxLen[] 记录以 arr[i] 为结尾的最长子序列的长度。
本例 maxLen [ 1 1 2 2 3 3 4 5 4 ]
又贪： 当 maxLen[i] == maxLen[i - 1] ，最小字典序要选 arr[i] ，跳过 i - 1。 反证 ：本例 maxLen[4] maxLen[5]均为3 ，对应元素 6、4 。 如果换位成 4、6，那么 maxLen[5] 的将变为 4 ，矛盾。 （即 maxLen[i] == maxLen[i - 1] 推出 arr[i] <= arr[i - 1]）
为了回避掉 arr[8] 对于 end[4] 的无效更新（因为 arr[7] 是最长序列结尾）

代码实现，见仁见智。